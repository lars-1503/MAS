**
```markdown
# Prompt: Generierung eines Java Spring Boot REST-Controllers für die Produktverwaltung

**Aufgabe:** Erstelle einen vollständigen Java Spring Boot REST-Controller für die Verwaltung von Produkten (CRUD-Operationen). Der Controller muss die folgenden Spezifikationen, Kontextinformationen und Akzeptanzkriterien erfüllen.

---

## 1. User Story

Als **Produktmanager** möchte ich Produkte über einen eigenen **REST-Controller** anlegen, anzeigen, bearbeiten und löschen können, um die Produktdatenpflege eigenständig und unabhängig von der Benutzerverwaltung zu ermöglichen.

---

## 2. Kontext

### 2.1. Geschäftskontext
*   **Ziel:** Steigerung der Effizienz in der Produktverwaltung durch direkte Kontrolle für die zuständige Rolle (Produktmanager/Admin). Dies reduziert die Abhängigkeit vom IT-Support oder der Benutzerverwaltung für grundlegende Produktaktualisierungen.
*   **Anwendungsbereich:** Dieses Feature ist Kernbestandteil des Backends für den E-Commerce-Shop und direkt mit dem Frontend für die Produktpräsentation sowie potenziell mit Lagerhaltungs- und Bestellsystemen verbunden.
*   **Geschäftliche Bedeutung:** Korrekte und aktuelle Produktdaten sind essenziell für den Verkaufserfolg. Verzögerungen oder Fehler in der Produktpflege können zu Umsatzeinbußen führen.

### 2.2. Technische Annahmen & Architektur
*   **Backend-Sprache/Framework:** Java mit Spring Boot.
*   **Datenbank:** PostgreSQL.
*   **ORM/Datenzugriff:** Spring Data JPA mit Hibernate.
*   **Authentifizierung/Autorisierung:** Zentraler Authentifizierungsdienst (z.B. Keycloak, Spring Security OAuth2) mit Rollen-basierter Zugriffskontrolle (RBAC).
*   **Angenommene Nutzerrolle:** Die zuständige Rolle für die Produktverwaltung ist **`ROLE_PRODUCT_MANAGER`** (oder `ROLE_ADMIN` mit entsprechenden Rechten).

---

## 3. Technische Spezifikation

### 3.1. Kerntechnologien und Bibliotheken
*   **Backend-Framework:** Spring Boot
*   **Datenbank:** PostgreSQL
*   **ORM/Datenzugriff:** Spring Data JPA (mit Hibernate)
*   **API-Design:** RESTful Web Services
*   **Datenformat:** JSON
*   **Validierung:** Jakarta Bean Validation (JSR 380)
*   **Sicherheit/Autorisierung:** Spring Security (mit RBAC)
*   **API-Dokumentation:** OpenAPI 3.0 (via Springdoc-UI)
*   **Transaktionsmanagement:** Spring Transaction Management (`@Transactional`)

### 3.2. Datenmodelle

#### 3.2.1. Datenbankentität: `Product`
Die Entität `Product` soll die folgenden Felder und Constraints gemäß der Spezifikation implementieren:

```java
package com.example.ecommerce.product.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;

@Entity
@Table(name = "products")
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id; // Automatisch generiert, Auto-Inkrement

    @Size(min = 1, max = 50, message = "SKU must be between 1 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9-]+$", message = "SKU can only contain alphanumeric characters and hyphens")
    @Column(unique = true, nullable = false, length = 50)
    private String sku; // Eindeutig, Formatierung beachten

    @Size(min = 1, max = 255, message = "Name must be between 1 and 255 characters")
    @Pattern(regexp = "^[a-zA-Z0-9 \\-\\']+$", message = "Name can only contain alphanumeric characters, spaces, hyphens, and apostrophes")
    @Column(nullable = false, length = 255)
    private String name; // Erforderlich, keine Leerzeichen am Anfang/Ende, bestimmte Zeichen erlaubt

    @Size(max = 4000, message = "Description can be up to 4000 characters")
    @Column(columnDefinition = "TEXT")
    private String description; // Optional, max. Länge, Markdown support denkbar

    @NotNull(message = "Price cannot be null")
    @DecimalMin(value = "0.00", message = "Price must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Price must have up to 2 decimal places")
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price; // Erforderlich, >= 0, 2 Nachkommastellen

    @Size(min = 3, max = 3, message = "Currency must be a 3-letter ISO code")
    @Pattern(regexp = "^[A-Z]{3}$", message = "Currency must be a 3-letter uppercase ISO code")
    @Column(nullable = false, length = 3)
    private String currency; // Erforderlich, ISO 4217 Code (z.B. "EUR")

    @Min(value = 0, message = "Stock quantity must be non-negative")
    @Column(name = "stock_quantity")
    private Integer stockQuantity; // Optional, >= 0

    @Size(max = 255, message = "Image URL can be up to 255 characters")
    @Pattern(regexp = "^(https?|ftp)://[^\\s/$.?#].[^\\s]*$", message = "Image URL format is invalid")
    @Column(name = "image_url", length = 255)
    private String imageUrl; // Optional, URL-Format validieren

    @ElementCollection
    @CollectionTable(name = "product_categories", joinColumns = @JoinColumn(name = "product_id"))
    @Column(name = "category_name")
    private List<String> categories; // Optional

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private ProductStatus status; // Erforderlich, Enum (DRAFT, ACTIVE, ARCHIVED, OUT_OF_STOCK)

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt; // Automatisch gesetzt

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt; // Automatisch gesetzt

    // GETTER & SETTER für alle Felder müssen generiert werden.
    // equals() und hashCode() basierend auf id und/oder sku implementieren.
    // Konstruktoren (NoArg, AllArg, etc.)
}
```

#### 3.2.2. Enum: `ProductStatus`
```java
package com.example.ecommerce.product.domain.entity;

public enum ProductStatus {
    DRAFT,
    ACTIVE,
    ARCHIVED,
    OUT_OF_STOCK
}
```

#### 3.2.3. Data Transfer Objects (DTOs)
*   **`ProductCreateDTO`**: Für `POST /api/v1/products`. Muss alle erforderlichen Felder für die Erstellung enthalten (außer `id`, `createdAt`, `updatedAt`). Muss Bean Validation Annotationen enthalten.
*   **`ProductUpdateDTO`**: Für `PUT /api/v1/products/{id}`. Muss alle aktualisierbaren Felder enthalten. `id` und `sku` dürfen nicht änderbar sein. Muss Bean Validation Annotationen enthalten.
*   **`ProductResponseDTO`**: Für `GET /api/v1/products/{id}` und Listenelemente. Muss alle relevanten Felder für die Anzeige enthalten: `id`, `sku`, `name`, `description`, `price`, `currency`, `stockQuantity`, `imageUrl`, `categories`, `status`, `createdAt`, `updatedAt`.
*   **`ProductListResponseDTO`**: Für `GET /api/v1/products`. Enthält eine Liste von `ProductResponseDTO` und Paginierungsmetadaten (z.B. `pageNumber`, `pageSize`, `totalElements`, `totalPages`).

**Anweisung:** Generiere die Klassen für diese DTOs mit den entsprechenden Feldern und Validierungsannotationen, basierend auf der `Product`-Entität.

### 3.3. API Endpunkte
Der Controller soll über den Basis-Pfad `/api/v1/products` erreichbar sein.

| HTTP-Methode | Pfad                     | Beschreibung                                   | Request Body        | Response Body         | Anmerkungen                                                                                                                             |
| :----------- | :----------------------- | :--------------------------------------------- | :------------------ | :-------------------- | :-------------------------------------------------------------------------------------------------------------------------------------- |
| **POST**     | `/api/v1/products`       | Erstellt ein neues Produkt.                    | `ProductCreateDTO`  | `ProductResponseDTO`  | Response mit `201 Created`. Muss die generierte `id` sowie `createdAt`/`updatedAt` enthalten. Standard-Status ist `DRAFT`.                 |
| **GET**      | `/api/v1/products`       | Ruft eine Liste von Produkten ab (paginiert). | N/A                 | `ProductListResponseDTO` | Unterstützt Paginierung (`page=0`, `size=20` als Defaults) und Sortierung (`sort=name,asc`).                                           |
| **GET**      | `/api/v1/products/{id}`  | Ruft die Details eines spezifischen Produkts ab. | N/A                 | `ProductResponseDTO`  | `{id}` ist die Produkt-ID.                                                                                                              |
| **PUT**      | `/api/v1/products/{id}`  | Aktualisiert ein bestehendes Produkt vollständig. | `ProductUpdateDTO`  | `ProductResponseDTO`  | `{id}` ist die Produkt-ID. SKU und ID dürfen nicht geändert werden. Response mit `200 OK`. `updatedAt` wird aktualisiert.                 |
| **DELETE**   | `/api/v1/products/{id}`  | Löscht ein spezifisches Produkt.              | N/A                 | N/A                   | Response mit `204 No Content`.                                                                                                          |

### 3.4. Autorisierungsstrategie
*   Alle Endpunkte sind nur für Benutzer mit der Rolle **`ROLE_PRODUCT_MANAGER`** oder **`ROLE_ADMIN`** zugänglich.
*   Implementierung mittels Spring Security und `@PreAuthorize` Annotationen auf Controller-Methoden (z.B. `@PreAuthorize("hasAnyRole('ROLE_PRODUCT_MANAGER', 'ROLE_ADMIN')")`).

### 3.5. Validierungsstrategie
*   Verwendung von Jakarta Bean Validation Annotationen auf `ProductCreateDTO` und `ProductUpdateDTO`.
*   Auslösen der Validierung durch `@Valid` auf Controller-Parametern.
*   Globale Fehlerbehandlung für Validierungsfehler über `@ControllerAdvice`, das eine standardisierte Fehlerantwort generiert.

### 3.6. Fehlerbehandlung und -meldung
*   Standardisierte Fehler-Response im JSON-Format:
    ```json
    {
        "timestamp": "...", // ISO 8601 Format
        "status": ...,      // HTTP Status Code (z.B. 400, 403, 404, 409)
        "error": "...",     // Kurze Fehlerbeschreibung (z.B. "Bad Request", "Forbidden")
        "message": "...",   // Detailliertere Fehlermeldung
        "path": "...",      // Angefragter API-Pfad
        "fieldErrors": [    // Liste von Fehlern pro Feld (nur bei Validierungsfehlern)
            {
                "field": "...", // Feldname
                "rejectedValue": "...", // Abgelehnter Wert
                "message": "..." // Feld-spezifische Fehlermeldung
            }
        ]
    }
    ```
*   Verwendung korrekter HTTP-Statuscodes (z.B. `400 Bad Request`, `403 Forbidden`, `404 Not Found`, `201 Created`, `204 No Content`, `409 Conflict`).

### 3.7. Dokumentation
*   Die API muss vollständig mit OpenAPI 3.0 Spezifikationen dokumentiert werden.
*   Integration von Springdoc-UI für eine interaktive API-Dokumentation (z.B. unter `/swagger-ui.html`).

### 3.8. Implementierungsdetails
*   **Service-Layer:** Ein `ProductService` wird die Geschäftslogik kapseln und Transaktionsmanagement (`@Transactional`) auf Methoden anwenden.
*   **Repository-Layer:** Ein `ProductRepository` (Spring Data JPA `JpaRepository<Product, Long>`) wird für Datenzugriffsoperationen bereitgestellt.
*   **Timestamps:** `createdAt` und `updatedAt` Felder sollen automatisch von der Anwendung gesetzt werden.
*   **Standard-Status:** Neue Produkte sollen standardmäßig den Status `DRAFT` erhalten, wenn kein anderer Status explizit gesetzt wird.

---

## 4. Akzeptanzkriterien

**Feature: Product Management API**

**Scenario Outline: Successfully create a new product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to create products
    When a POST request is made to "/api/v1/products" with a valid ProductCreateDTO
    Then the response status code should be "201 Created"
    And the response body should contain the created product details, including a generated unique ID
    And the product should be persisted in the database with the provided details and the initial status "DRAFT"
    And the `createdAt` and `updatedAt` timestamps should be set to the current time

**Examples:**
    | sku         | name           | description                | price  | currency | stockQuantity | imageUrl                            | categories       | status     |
    |-------------|----------------|----------------------------|--------|----------|---------------|-------------------------------------|------------------|------------|
    | SKU-123     | Test Product A | A great test product       | 19.99  | EUR      | 100           | http://example.com/img/a.jpg        | ["Electronics"]  | DRAFT      |
    | PROD-ABC-XYZ| Another Item   | Description for item       | 120.50 | USD      | 50            | https://images.example.com/img.png | ["Clothing", "Sale"] | ACTIVE     |

**Scenario: Attempt to create a product with invalid data (missing required field)**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to create products
    When a POST request is made to "/api/v1/products" with a ProductCreateDTO missing the 'name' field
    Then the response status code should be "400 Bad Request"
    And the response body should follow the standard error format
    And the `fieldErrors` list in the response body should contain an entry for 'name' with a message like "Name cannot be empty"

**Scenario: Attempt to create a product with invalid data (invalid price format)**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to create products
    When a POST request is made to "/api/v1/products" with a ProductCreateDTO containing `price: "invalid-price"`
    Then the response status code should be "400 Bad Request"
    And the response body should follow the standard error format
    And the `fieldErrors` list in the response body should contain an entry for 'price' with a message indicating a format issue (e.g., "Price must be a valid number")

**Scenario: Attempt to create a product with invalid data (SKU pattern violation)**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to create products
    When a POST request is made to "/api/v1/products" with a ProductCreateDTO containing `sku: "Invalid SKU!"`
    Then the response status code should be "400 Bad Request"
    And the response body should follow the standard error format
    And the `fieldErrors` list in the response body should contain an entry for 'sku' with a message like "SKU can only contain alphanumeric characters and hyphens"

**Scenario: Attempt to create a product with duplicate SKU**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And a product with SKU "EXISTING-SKU" already exists in the database
    And the user has the permission to create products
    When a POST request is made to "/api/v1/products" with a valid ProductCreateDTO where `sku` is "EXISTING-SKU"
    Then the response status code should be "409 Conflict"
    And the response body should follow the standard error format
    And the general `message` field should indicate a conflict due to a duplicate SKU

**Scenario: Attempt to create a product without sufficient authorization**
    Given a user is authenticated with a role other than "ROLE_PRODUCT_MANAGER" or "ROLE_ADMIN"
    When a POST request is made to "/api/v1/products" with a valid ProductCreateDTO
    Then the response status code should be "403 Forbidden"

**Scenario Outline: Successfully retrieve a list of products with pagination and sorting**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to read products
    And there are at least 15 products in the database with varying names
    When a GET request is made to "/api/v1/products" with query parameters `?page=1&size=10&sort=name,desc`
    Then the response status code should be "200 OK"
    And the response body should be a `ProductListResponseDTO`
    And the `content` field of the response body should be a list containing exactly 10 `ProductResponseDTO` objects
    And the products in the `content` list should be sorted by `name` in descending order
    And the pagination metadata should indicate `pageNumber = 1`, `pageSize = 10`, and `totalElements` greater than or equal to 15

**Scenario Outline: Retrieve a list of products with default pagination and sorting**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to read products
    And there are 5 products in the database
    When a GET request is made to "/api/v1/products" without any query parameters
    Then the response status code should be "200 OK"
    And the response body should be a `ProductListResponseDTO`
    And the `content` field of the response body should be a list containing all 5 `ProductResponseDTO` objects
    And the pagination metadata should indicate `pageNumber = 0`, `pageSize = 20` (default size), and `totalElements = 5`

**Scenario: Attempt to retrieve a list of products without sufficient authorization**
    Given a user is authenticated with a role other than "ROLE_PRODUCT_MANAGER" or "ROLE_ADMIN"
    When a GET request is made to "/api/v1/products"
    Then the response status code should be "403 Forbidden"

**Scenario Outline: Successfully retrieve details of a specific product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to read products
    And a product with ID <productId> exists in the database with SKU <sku> and name <productName>
    When a GET request is made to "/api/v1/products/<productId>"
    Then the response status code should be "200 OK"
    And the response body should be a `ProductResponseDTO`
    And the `id`, `sku`, and `name` fields in the response body should match <productId>, <sku>, and <productName> respectively

**Examples:**
    | productId | sku        | productName       |
    |-----------|------------|-------------------|
    | 1         | SKU-123    | Test Product A    |
    | 2         | PROD-ABC-XYZ| Another Item      |

**Scenario: Attempt to retrieve details of a non-existent product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to read products
    And no product exists with ID "999"
    When a GET request is made to "/api/v1/products/999"
    Then the response status code should be "404 Not Found"
    And the response body should follow the standard error format
    And the `message` field should indicate that the product with ID "999" was not found

**Scenario: Attempt to retrieve details of a specific product without sufficient authorization**
    Given a user is authenticated with a role other than "ROLE_PRODUCT_MANAGER" or "ROLE_ADMIN"
    And a product with ID 1 exists in the database
    When a GET request is made to "/api/v1/products/1"
    Then the response status code should be "403 Forbidden"

**Scenario Outline: Successfully update an existing product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to update products
    And a product with ID <productId> exists in the database with SKU <sku>
    When a PUT request is made to "/api/v1/products/<productId>" with a valid `ProductUpdateDTO` containing new details for `name` and `price`
    Then the response status code should be "200 OK"
    And the response body should be a `ProductResponseDTO` containing the updated `name` and `price`
    And the `updatedAt` timestamp in the response body should be different from the `createdAt` timestamp and reflect the update time
    And the product in the database should reflect the updated `name` and `price`

**Examples:**
    | productId | sku        | updatedName       | updatedPrice |
    |-----------|------------|-------------------|--------------|
    | 1         | SKU-123    | Updated Product A | 25.00        |
    | 2         | PROD-ABC-XYZ| New Item Name     | 110.00       |

**Scenario: Attempt to update a product with invalid data (negative stock quantity)**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to update products
    And a product with ID 1 exists in the database
    When a PUT request is made to "/api/v1/products/1" with a `ProductUpdateDTO` containing `stockQuantity: -5`
    Then the response status code should be "400 Bad Request"
    And the response body should follow the standard error format
    And the `fieldErrors` list in the response body should contain an entry for 'stockQuantity' with a message like "Stock quantity must be non-negative"

**Scenario: Attempt to update a non-existent product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to update products
    And no product exists with ID "999"
    When a PUT request is made to "/api/v1/products/999" with a valid `ProductUpdateDTO`
    Then the response status code should be "404 Not Found"
    And the response body should follow the standard error format
    And the `message` field should indicate that the product with ID "999" was not found

**Scenario: Attempt to update a product without sufficient authorization**
    Given a user is authenticated with a role other than "ROLE_PRODUCT_MANAGER" or "ROLE_ADMIN"
    And a product with ID 1 exists in the database
    When a PUT request is made to "/api/v1/products/1" with a valid `ProductUpdateDTO`
    Then the response status code should be "403 Forbidden"

**Scenario: Attempt to update a product's SKU via PUT request**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to update products
    And a product with ID 1 exists in the database with SKU "SKU-123"
    When a PUT request is made to "/api/v1/products/1" with a `ProductUpdateDTO` that includes `sku: "NEW-SKU-456"`
    Then the response status code should be "400 Bad Request"
    And the response body should follow the standard error format
    And the `fieldErrors` list in the response body should contain an entry for 'sku' with a message indicating it's not allowed to update the SKU, or the SKU is invalid if validation applies to existing ones.
    And the product's SKU in the database should remain "SKU-123"

**Scenario Outline: Successfully delete a product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to delete products
    And a product with ID <productId> exists in the database
    When a DELETE request is made to "/api/v1/products/<productId>"
    Then the response status code should be "204 No Content"
    And a subsequent GET request to "/api/v1/products/<productId>" should return a "404 Not Found" status

**Examples:**
    | productId |
    |-----------|
    | 1         |
    | 2         |

**Scenario: Attempt to delete a non-existent product**
    Given a user is authenticated with the role "ROLE_PRODUCT_MANAGER"
    And the user has the permission to delete products
    And no product exists with ID "999"
    When a DELETE request is made to "/api/v1/products/999"
    Then the response status code should be "404 Not Found"
    And the response body should follow the standard error format
    And the `message` field should indicate that the product with ID "999" was not found

**Scenario: Attempt to delete a product without sufficient authorization**
    Given a user is authenticated with a role other than "ROLE_PRODUCT_MANAGER" or "ROLE_ADMIN"
    And a product with ID 1 exists in the database
    When a DELETE request is made to "/api/v1/products/1"
    Then the response status code should be "403 Forbidden"
```