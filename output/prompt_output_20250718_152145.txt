I have analyzed the user story, the provided context including open questions, and the assumed project context. I have also processed the enriched user story and the generated acceptance criteria. My goal is to combine all this information into a single, clear, and actionable Markdown prompt for a coding LLM.

The prompt needs to cover:
1.  **User Story:** The high-level goal and benefit.
2.  **Assumed Context:** The technical stack, architecture, and conventions.
3.  **Detailed Requirements:** Incorporating clarifications and addressing open questions where possible, defining entities, DTOs, endpoints, validation rules, and error handling.
4.  **API Specifications:** Details on endpoints, HTTP methods, paths, request/response formats.
5.  **Testing Requirements:** Emphasis on integration tests.
6.  **Documentation Requirements:** Specification for OpenAPI/Swagger.
7.  **Security:** Integration with Spring Security.
8.  **Open Questions:** Explicitly list points needing further clarification.
9.  **Acceptance Criteria:** Provide concrete examples of expected behavior.
10. **Final Instruction:** A clear call to action for the LLM to generate code.

I will structure this using Markdown, ensuring clarity and completeness. I must *not* generate any actual code snippets, but describe the structure and requirements for the code.# Prompt für Code-Generierung: Produktverwaltung REST API

Dieser Prompt beschreibt die Anforderungen für die Implementierung einer RESTful API zur Verwaltung von Produkten in einer Spring Boot Anwendung.

## 1. User Story

**Rolle:** Ein definierter Benutzer (z.B. 'ADMIN', 'PRODUCT_MANAGER'), der über das Authentifizierungs- und Autorisierungsframework (Spring Security) gesteuert wird.
**Funktion:** Verwaltung von Produkten mittels CRUD-Operationen (Anlegen, Anzeigen, Bearbeiten, Löschen) über einen eigenen REST-Controller. Jedes Produkt hat mindestens die Attribute `id`, `name`, `preis`, `beschreibung`, `sku`, `bestand` und `aktiv`. Eingaben werden validiert (Produktname nicht leer, Preis nicht negativ, SKU eindeutig), und fehlerhafte Eingaben führen zu klaren Fehlermeldungen im RFC 7807 Format. Die Implementierung umfasst Integrationstests für alle Endpunkte und die Dokumentation mittels OpenAPI.
**Nutzen:** Ermöglicht die effiziente und konsistente Verwaltung von Produktdaten, verbessert die Datenintegrität und trägt zur Stabilität und Benutzerfreundlichkeit der Anwendung bei.

## 2. Angenommener Technischer Kontext & Architektur

*   **Tech Stack:** Java 17+, Spring Boot 3.x, Spring Web, Spring Data JPA, Hibernate, PostgreSQL, Lombok, JUnit 5, Mockito, Spring Security.
*   **Architektur:** Dreischichtige Architektur (Controller, Service, Repository). Verwendung von DTOs für die API-Schicht und JPA-Entities für das Domain-Modell.
*   **Paketstruktur:**
    *   `com.example.domain.model`: JPA Entities (z.B. `Product`)
    *   `com.example.repository`: Spring Data JPA Repositories (z.B. `ProductRepository`)
    *   `com.example.service`: Service-Schicht (z.B. `ProductService`)
    *   `com.example.controller`: REST Controller (z.B. `ProductController`)
    *   `com.example.controller.dto`: Data Transfer Objects (z.B. `ProductCreateDTO`, `ProductResponseDTO`)
*   **API Gateway:** Es kann ein API Gateway vorgeschaltet sein; Pfade sollten daher gut definiert sein.
*   **Sicherheit:** Spring Security mit JWT-Authentifizierung. Berechtigungsprüfungen mittels `@PreAuthorize`.
*   **Fehlerbehandlung:** Zentralisiert über `@ControllerAdvice`, RFC 7807 Problem Details für Fehlerantworten.
*   **Datenbank:** PostgreSQL. Schema-Management (z.B. via Flyway/Liquibase) wird angenommen.
*   **Dokumentation:** OpenAPI 3.0 (Swagger), generiert mit Springdoc OpenAPI.
*   **Validierung:** Bean Validation (JSR 380) mit Annotationen wie `@NotNull`, `@Size`, `@DecimalMin`, `@Pattern`.

## 3. Detaillierte Anforderungen

### 3.1. Produktmodell (JPA Entity)

*   **Paket:** `com.example.domain.model`
*   **Klasse:** `Product`
*   **Attribute:**
    *   `id`: `Long`, `@Id`, `@GeneratedValue` (Sequence/Identity)
    *   `name`: `String`, nicht null, min. 1 Zeichen, max. 255 Zeichen (`@NotNull`, `@Size(min=1, max=255)`)
    *   `preis`: `BigDecimal`, nicht null, >= 0.00, max. 2 Dezimalstellen (`@NotNull`, `@DecimalMin(value="0.00")`, `@Digits(integer=10, fraction=2)`)
    *   `beschreibung`: `String`, max. 2000 Zeichen (`@Size(max=2000)`)
    *   `sku`: `String`, nicht null, min. 1 Zeichen, max. 50 Zeichen, eindeutig (`@NotNull`, `@Size(min=1, max=50)`, `@Column(unique=true)`)
    *   `bestand`: `Integer`, nicht null, >= 0 (`@NotNull`, `@Min(0)`)
    *   `aktiv`: `Boolean`, nicht null (`@NotNull`)
*   **Hinweise:**
    *   Das Verhalten bei der Löschung (Hard- vs. Soft-Delete) muss basierend auf Q03 spezifiziert und implementiert werden.
    *   Für `preis` ist `BigDecimal` obligatorisch.

### 3.2. Data Transfer Objects (DTOs)

*   **Paket:** `com.example.controller.dto`
*   **Klassen:**
    *   `ProductCreateDTO`: Enthält Felder für `name`, `preis`, `beschreibung`, `sku`, `bestand`, `aktiv`. Validierungsannotationen analog zur Entity.
    *   `ProductUpdateDTO`: Enthält Felder für `name`, `preis`, `beschreibung`, `sku`, `bestand`, `aktiv`. Alle Felder sollten optional sein (für partielle Updates) oder analog zu `ProductCreateDTO`, wenn PUT für vollständige Updates verwendet wird.
    *   `ProductResponseDTO`: Enthält alle Felder der Entity (`id`, `name`, `preis`, `beschreibung`, `sku`, `bestand`, `aktiv`). Kann zusätzliche Felder wie HATEOAS-Links enthalten.
    *   `ProductListResponseDTO`: Enthält eine Liste von `ProductResponseDTO` (`content`) und Paginierungsinformationen (`pageable`, z.B. `PageableResponse` Objekt).

### 3.3. REST Controller & Endpunkte

*   **Basis-Pfad:** `/products`
*   **Paket:** `com.example.controller`
*   **Klasse:** `ProductController`
*   **Endpunkte:**

    | HTTP-Methode | Pfad          | Operation ID       | Zusammenfassung             | Berechtigung     | Request Body      | Response (Erfolg) | Mögliche Fehlerantworten                                    |
    | :---------- | :------------ | :----------------- | :-------------------------- | :--------------- | :---------------- | :---------------- | :---------------------------------------------------------- |
    | `POST`      | `/`           | `createProduct`    | Produkt anlegen             | `ROLE_ADMIN`     | `ProductCreateDTO` | `201`, `ProductResponseDTO` | `400` (Validierung), `401`, `403`, `409` (DUPLIKAT SKU)     |
    | `GET`       | `/`           | `getProducts`      | Produkte abrufen (Liste)    | `ROLE_USER`      | -                 | `200`, `ProductListResponseDTO` | `400` (ungültige Parameter), `401`, `403`                  |
    | `GET`       | `/{id}`       | `getProductById`   | Produkt abrufen (nach ID)   | `ROLE_USER`      | -                 | `200`, `ProductResponseDTO` | `400` (ID ungültig), `401`, `403`, `404`                    |
    | `PUT`       | `/{id}`       | `updateProduct`    | Produkt aktualisieren       | `ROLE_ADMIN`     | `ProductUpdateDTO` | `200`, `ProductResponseDTO` | `400` (Validierung), `401`, `403`, `404`, `409` (DUPLIKAT SKU) |
    | `DELETE`    | `/{id}`       | `deleteProduct`    | Produkt löschen             | `ROLE_ADMIN`     | -                 | `204`             | `400` (ID ungültig), `401`, `403`, `404`                    |

*   **Paginierung & Sortierung (für `GET /products`):**
    *   Parameter: `page` (Integer, default 0), `size` (Integer, default 20), `sort` (String, z.B. `name,asc`).
    *   Verwendung von Spring Data's `Pageable` im Service-Layer.

### 3.4. Fehlerbehandlung

*   Implementierung eines globalen Exception Handlers (`@ControllerAdvice`).
*   Verwendung von RFC 7807 Problem Details für Fehlerantworten (JSON-Format mit `type`, `title`, `status`, `detail`, `instance`).
*   Spezifische Exception-Klassen für Anwendungsfehler (z.B. `ProductNotFoundException`, `SkuAlreadyExistsException`, `InvalidPriceException`).

### 3.5. Dokumentation

*   Verwendung von Springdoc OpenAPI zur Generierung der OpenAPI 3.0 Spezifikation.
*   Annotationen (`@Operation`, `@Parameter`, `@ApiResponse`, `@RequestBody`, etc.) auf Controller-Ebene zur Beschreibung der Endpunkte, Parameter, Request/Response-Modelle und Statuscodes.

### 3.6. Integrationstests

*   Erstellung von Integrationstests für alle CRUD-Endpunkte.
*   Verwendung von JUnit 5, Spring Boot Test und MockMvc.
*   Testabdeckung von Erfolgsfällen (Happy Paths) sowie Fehlerfällen (Validierungsfehler, nicht gefundene Ressourcen, fehlende Berechtigungen, Duplikate).

### 3.7. Sicherheit

*   Absicherung aller Endpunkte gemäß den definierten Rollen (`@PreAuthorize`).
*   Beispiel: `@PreAuthorize("hasRole('ADMIN')")` für `POST`, `PUT`, `DELETE`.

## 4. Offene Punkte zur Klärung (WICHTIG!)

*   **Q01 (Rolle):** Genaue Definition der Benutzerrolle(n), die Produktmanagement-Operationen durchführen dürfen.
*   **Q02 (Attribute):** Welche weiteren Produktattribute sind erforderlich? Welche Datentypen und Validierungsregeln gelten für diese?
*   **Q03 (Validierung/Fehler):**
    *   Sind spezifische Obergrenzen für den Preis erforderlich?
    *   Was bedeutet "nicht leer" für den Produktnamen genau (Min/Max Länge)?
    *   Wie soll das Verhalten bei Löschung eines referenzierten Produkts sein (z.B. über Soft-Delete)?
*   **Q04 (Endpunkte/Schemas):** Genaue Spezifikation der JSON-Schemas für Request/Response DTOs, falls abweichend von der Grundstruktur.
*   **Q06 (Dokumentation):** Gibt es spezielle Anforderungen an die OpenAPI-Dokumentation über die Standardbeschreibung hinaus?
*   **Q07 (Abhängigkeiten):** Gibt es explizite Abhängigkeiten zu externen Services oder spezifische Datenbank-Interaktionsmuster?
*   **Q08 (Performance):** Gibt es spezifische Performance-Anforderungen (z.B. Latenzzeiten)?
*   **Q09 (Paginierung/Sortierung):** Welche Felder sollen für die Sortierung verfügbar sein? Gibt es spezifische Paginierungslogiken?
*   **Q10 (Sicherheit):** Gibt es zusätzliche Sicherheitsaspekte über die Rollenbasierte Zugriffskontrolle hinaus (z.B. IP-Beschränkungen)?

## 5. Akzeptanzkriterien (Beispiele)

*(Die folgenden Kriterien sollten als Beispiele für die erwartete Funktionalität betrachtet werden. Sie sind detailliert ausgeführt, um das LLM zu leiten.)*

*   **AC1: Produkt erfolgreich anlegen:** Ein `ADMIN` kann ein neues Produkt mit allen erforderlichen Feldern erfolgreich per `POST /products` anlegen. Die Antwort ist `201 Created` mit dem erstellten Produkt und dessen `id`.
*   **AC2: Anlegen mit Validierungsfehler (Name):** Ein Versuch, ein Produkt ohne `name` anzulegen, führt zu `400 Bad Request` mit einer klaren Fehlermeldung für das `name`-Feld.
*   **AC3: Anlegen mit Validierungsfehler (Preis):** Ein Versuch, ein Produkt mit einem negativen `preis` anzulegen, führt zu `400 Bad Request` mit einer Fehlermeldung für `preis`.
*   **AC4: Anlegen mit DUPLIKAT SKU:** Ein Versuch, ein Produkt mit einer bereits existierenden `sku` anzulegen, führt zu `409 Conflict`.
*   **AC5: Produktliste abrufen (Paginierung):** Ein `USER` kann Produkte mit `GET /products?page=0&size=10` abrufen. Die Antwort enthält 10 Produkte und Paginierungsinformationen.
*   **AC6: Produkt nach ID abrufen:** Ein `USER` kann ein existierendes Produkt per `GET /products/{id}` abrufen. Die Antwort ist `200 OK` mit dem `ProductResponseDTO`.
*   **AC7: Produkt nach ID abrufen (Nicht gefunden):** Eine Anfrage für eine nicht existierende Produkt-ID führt zu `404 Not Found`.
*   **AC8: Produkt aktualisieren:** Ein `ADMIN` kann ein existierendes Produkt per `PUT /products/{id}` mit neuen Daten aktualisieren. Die Antwort ist `200 OK` mit dem aktualisierten `ProductResponseDTO`.
*   **AC9: Produkt löschen:** Ein `ADMIN` kann ein existierendes Produkt per `DELETE /products/{id}` löschen. Die Antwort ist `204 No Content`.
*   **AC10: Zugriff verweigert (Autorisierung):** Ein Benutzer mit unzureichender Rolle (z.B. `USER` versucht zu löschen) erhält `403 Forbidden`.
*   **AC11: Zugriff verweigert (Authentifizierung):** Ein nicht authentifizierter Benutzer erhält `401 Unauthorized` bei Zugriff auf eine geschützte Ressource.
*   **AC12: OpenAPI Dokumentation:** Die API-Dokumentation ist unter `/v3/api-docs` (oder konfiguriertem Pfad) verfügbar und beschreibt alle Endpunkte korrekt.

---

Bitte generiere basierend auf diesen Informationen den vollständigen Code für die Produktverwaltung REST API, einschließlich Entitäten, Repositories, Services, DTOs, Controller, Validierungen und grundlegender Fehlerbehandlung. Die Integration mit Spring Security für die Rollenprüfung ist obligatorisch. Die Implementierung soll den oben genannten Standards und Best Practices folgen.